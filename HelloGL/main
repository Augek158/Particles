//
//  main.cpp
//  HelloGL
//
//  Created by August Nam-Ki Ek on 2014-05-04.
//  Copyright (c) 2014 August Nam-Ki Ek. All rights reserved.
//

#define GLFW_INCLUDE_GLCOREARB
#include <iostream>
#include <cmath>
#include "Shader.h"
#include "ShaderProgram.h"
#include "TextureUtils.h"
#include "Window.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

int main(int argc, const char *argv[]){
    
    Window* window = new Window(640, 360, "Modern OpenGL");
    ShaderProgram* RenderProgram;
    ShaderProgram* TransformProgram;
    
    Shader* transformShader;
    Shader* vertexShader;
    Shader* fragmentShader;
    
    window->makeContextCurrent();
    
    glClearColor(0.0, 0.0, 0.0, 0.0);
    
    RenderProgram = new ShaderProgram();
    vertexShader = new Shader("MyVertexShader.vs", GL_VERTEX_SHADER);
    fragmentShader = new Shader("MyFragmentShader.fs", GL_FRAGMENT_SHADER);
    
    RenderProgram->attachShader(vertexShader);
    RenderProgram->attachShader(fragmentShader);
    
    RenderProgram->bindFragDataLocation(0, "fragData");
    RenderProgram->link();
    

    
    // Initalizing TransformShader
    TransformProgram = new ShaderProgram();
    transformShader = new Shader("MyTransformShader.vs", GL_VERTEX_SHADER);
    
    TransformProgram->attachShader(transformShader);
    const GLchar* feedbackVaryings[] = {"outPosition"};
    glTransformFeedbackVaryings(TransformProgram->getProgramID(), 1, feedbackVaryings, GL_INTERLEAVED_ATTRIBS);
    
    TransformProgram->link();
    TransformProgram->use();
    
    GLuint myVAO;
    glGenVertexArrays(1, &myVAO);
    glBindVertexArray(myVAO);
    
    
    delete transformShader;
    delete vertexShader;
    delete fragmentShader;
    
    
    std::cout << glGetString(GL_VERSION) << std::endl;
    
    GLfloat particleData[] = { 1.0f, 2.0f, 3.0f, 4.0f, 5.0f };
    
    GLuint vbo;
    glGenBuffers(1, &vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, sizeof(particleData), data, GL_STATIC_DRAW);
    
    GLint positionLoc = TransformProgram->getAttribLoc("inPosition");
    glEnableVertexAttribArray(positionLoc);
    glVertexAttribPointer(positionLoc, 1, GL_FLOAT, GL_FALSE, 0, 0);
    
    GLuint tbo;
    glGenBuffers(1, &tbo);
    glBindBuffer(GL_ARRAY_BUFFER, tbo);
    glBufferData(GL_ARRAY_BUFFER, sizeof(particleData), nullptr, GL_STATIC_READ);
    
    glEnable(GL_RASTERIZER_DISCARD);
    


    

    
    delete window;
    delete RenderProgram;
    delete TransformProgram;
    glfwTerminate();
    return 0;
}